'''
AES
input : 128 bits
output : 128 bits
cipher key : 128 or 192 or 256 bits
##########################################
1. xor operation with roundKey(addroundkey)
2. substitute bytes(SubBytes)
3. Shift Rows
4. Mix Columns
5. xor operation with roundKey(addroundKey)
6. repeat round-1 times (2 -5)
7. operate the last round without MixColumns
###########################################
'''

###          Key Length    Block Length    Number of Rounds
### AES-128      4              4                 10
### AES-192      6              4                 12
### AES-256      8              4                 14

import finite_field_mult

SBOX = [
#ROW  0    1     2     3     4     5     6     7      8     9    10    11    12    13    14    15
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, # ROW 0

    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, # ROW 1

    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, # ROW 2

    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, # ROW 3

    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, # ROW 4

    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, # ROW 5

    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, # ROW 6

    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, # ROW 7

    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, # ROW 8

    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, # ROW 9

    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, # ROW 10

    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, # ROW 11

    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, # ROW 12

    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, # ROW 13

    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, # ROW 14

    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, # ROW 15
]

inv_SBOX = [
#ROW 0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, # ROW 0

    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, # ROW 1

    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, # ROW 2

    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, # ROW 3

    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, # ROW 4

    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, # ROW 5

    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, # ROW 6

    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, # ROW 7

    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, # ROW 8

    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, # ROW 9

    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, # ROW 10

    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, # ROW 11

    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, # ROW 12

    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, # ROW 13

    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, # ROW 14

    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, # ROW 15
]

Rcon = [
    # 236 elements
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,

    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,

    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,

    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,

    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,

    0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,

    0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,

    0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,

    0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,

    0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,

    0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,

    0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,

    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,

    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,

    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,

    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,

    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,

    0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,

    0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,

    0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb ]

# learned from https://github.com/boppreh/aes/blob/master/aes.py
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

Nb = 4 # size of state column

''' inverse transformation of SubBytes function is invSubBytes function  '''
def SubBytes(state):
    for i in range(Nb*4):
        state[i] = SBOX[state[i]]
    return state

def invSubBytes(state):
    for i in range(Nb*4):
        state[i] = inv_SBOX[state[i]]
    return state


def ShiftRows(state):
    tmp13 = state[13]
    state[13] = state[1]
    state[1] = state[5]
    state[5] = state[9]
    state[9] = tmp13

    tmp15 = state[15]
    state[15] = state[11]
    state[11] = state[7]
    state[7] = state[3]
    state[3] = tmp15

    tmp2 = state[2]
    state[2] = state[10]
    state[10] = tmp2

    tmp6 = state[6]
    state[6] = state[14]
    state[14] = tmp6
    #state[0][1], state[1][1], state[2][1], state[3][1] = state[1][1], state[2][1], state[3][1], state[0][1]
    #state[0][2], state[1][2], state[2][2], state[3][2] = state[2][2], state[3][2], state[0][2], state[1][2]
    #state[0][3], state[1][3], state[2][3], state[3][3] = state[3][3], state[0][3], state[1][3], state[2][3]
    return state


def inv_ShiftRows(state):
    tmp = state[13]
    state[13] = state[9]
    state[9] = state[5]
    state[5] = state[1]
    state[1] = tmp

    tmp = state[10]
    tmp2 = state[14]
    state[10] = state[2]
    state[14] = state[6]
    state[2] = tmp
    state[6] = tmp2

    tmp = state[11]
    state[11] = state[15]
    state[15] = state[3]
    state[3] = state[7]
    state[7] = tmp
    #    state[0][1], state[1][1], state[2][1], state[3][1] = state[3][1], state[0][1], state[1][1], state[2][1]
    #    state[0][2], state[1][2], state[2][2], state[3][2] = state[2][2], state[3][2], state[0][2], state[1][2]
    #    state[0][3], state[1][3], state[2][3], state[3][3] = state[1][3], state[2][3], state[3][3], state[0][3]
    return state


def mixColumn(state):
    block = []
    while len(block) < 16: block.append(0)
    k = 0
    while k <= 16-4:
        block[k] = GF(2,state[k])^GF(3,state[k+1])^GF(1,state[k+2])^GF(1,state[k+3])
        block[k+1] = GF(1,state[k])^GF(2,state[k+1])^GF(3,state[k+2])^GF(1,state[k+3])
        block[k+2] = GF(1,state[k])^GF(1,state[k+1])^GF(2,state[k+2])^GF(3,state[k+3])
        block[k+3] = GF(3,state[k])^GF(1,state[k+1])^GF(1,state[k+2])^GF(2,state[k+3])
        k += 4
    return block

def InvMixColumns(state):
    block = []
    while len(block) < 16: block.append(0)
    k = 0
    while k <= 16-4:
        block[k] = GF(14,state[k])^GF(11,state[k+1])^GF(13,state[k+2])^GF(9,state[k+3])
        block[k+1] = GF(9,state[k]) ^GF(14,state[k+1])^GF(11,state[k+2])^GF(13,state[k+3])
        block[k+2] = GF(13,state[k])^GF(9,state[k+1]) ^GF(14,state[k+2])^GF(11,state[k+3])
        block[k+3] = GF(11,state[k])^GF(13,state[k+1])^GF(9,state[k+2]) ^GF(14,state[k+3])
        k += 4
    return block

# Galois multiplication in GF(2^8) of 8 bit characters a and b
def GF(a, b):
    r = 0
    for times in range(8):
        if (b & 1) == 1: r = r ^ a
        if r > 0x100: r = r ^ 0x100
        # keep r 8 bit
        hi_bit_set = (a & 0x80)
        a = a << 1
        if a > 0x100:
            # keep a 8 bit
            a = a ^ 0x100
        if hi_bit_set == 0x80:
            a = a ^ 0x1b
        if a > 0x100:
            # keep a 8 bit
            a = a ^ 0x100
        b = b >> 1
        if b > 0x100:
            # keep b 8 bit
            b = b ^ 0x100
    return r

def AddroundKey(State, Key):
    for i in range(Nb*4):
        if i < len(Key): State[i] = State[i] ^ Key[i]
    return State

def RoundKeyPointer(RoundKey, Next_RoundKey):
    NextRoundKey = []
    k = 0

    while len(NextRoundKey) < Nb*4 : NextRoundKey.append(0)
    for i in range(4):
        NextRoundKey[i * 4] = RoundKey[Next_RoundKey + k]
        NextRoundKey[i * 4 + 1] = RoundKey[Next_RoundKey + k + 1]
        NextRoundKey[i * 4 + 2] = RoundKey[Next_RoundKey + k + 2]
        NextRoundKey[i * 4 + 3] = RoundKey[Next_RoundKey + k + 3]
        k += 4  # next column
    return NextRoundKey

def SubWord(state):
    ### substitute first four bytes of input state ###
    return SBOX[state]

def RotWord(state):
    T = state[0]
    state[0] = state[1]
    state[1] = state[2]
    state[2] = state[3]
    state[3] = T
    return state

def KeyExpansion(Key, Key_size, RoundKeySize):

    i = 0
    rconIteration = 1
    word = [0, 0, 0, 0]
    RoundKey = []
    while len(RoundKey) < RoundKeySize: RoundKey.append(0)

    for j in range(Key_size): RoundKey[j] = Key[j]

    i += Key_size
    while i < RoundKeySize:
        for k in range(4):
            word[k] = RoundKey[(i - 4) + k]

        # Every 16,24,32 bytes
        if i % Key_size == 0:
            word = RotWord(word)
            for r in range(4):
                word[r] = SubWord(word[r])
            word[0] ^= Rcon[rconIteration]
            rconIteration += 1

        # For 256-bit keys, we add an extra Sbox to the calculation
        if Key_size == 256/8 and (i % Key_size) == Nb*4:
            for e in range(4): word[e] = SubWord(word[e])
        for m in range(4):
            RoundKey[i] = RoundKey[i - Key_size] ^ word[m]
            i += 1

    return RoundKey

def Encryption(plaintext, key, numberOfRounds):
    RoundKeySize = 128 / 8
    state = []

    while len(state) < len(key): state.append(0)
    for i in range(RoundKeySize):
        if i < len(plaintext): state[i] = plaintext[i]

    RoundKey_Array_size = Nb*4*(numberOfRounds+1)
    RoundKey = KeyExpansion(key, len(key), RoundKey_Array_size)

    state = AddroundKey(state, key)
    i = 0
    while i < numberOfRounds:
        i += 1
        state = SubBytes(state)
        state = ShiftRows(state)
        if i < numberOfRounds : state = mixColumn(state)
        state = AddroundKey(state, RoundKeyPointer(RoundKey, 4*Nb*i))

    return state

def Decryption(plaintext, key, numberOfRounds):
    RoundKeySize = 128 / 8
    state = []

    while len(state) < len(key): state.append(0)
    for i in range(RoundKeySize):
        if i < len(plaintext): state[i] = plaintext[i]

    RoundKey_Array_size = Nb*4*(numberOfRounds+1)
    RoundKey = KeyExpansion(key, len(key), RoundKey_Array_size)

    state = AddroundKey(state, RoundKeyPointer(RoundKey, Nb*4*numberOfRounds))
    i = numberOfRounds
    while i > 0:
        i -= 1
        state = inv_ShiftRows(state)
        state = invSubBytes(state)
        state = AddroundKey(state, RoundKeyPointer(RoundKey, 4*Nb*i))
        if i > 0 : state = InvMixColumns(state)

    return state

def main():
    CipherKeySize = 128 / 8
    PlaintextString = "1234567890ABCDEF"
    CipherKeyString = "0000000000000001"

    PlaintextArray = []
    CipherKeyArray = []
    while len(PlaintextArray) < Nb*4: PlaintextArray.append(0)
    while len(CipherKeyArray) < CipherKeySize: CipherKeyArray.append(0)

    for i in range(len(list(PlaintextString))): PlaintextArray[i] = int(list(PlaintextString)[i].encode("hex"), 16)  # 16 stands for HEX
    for i in range(len(list(CipherKeyString))): CipherKeyArray[i] = int(list(CipherKeyString)[i].encode("hex"), 16)  # 16 stands for HEX
    print(PlaintextArray)
    Cipher_message = Encryption(PlaintextArray, CipherKeyArray, CipherKeySize)
    print("plaintext : ", ''.join(str('%0.2X' % n).decode("hex") for n in PlaintextArray))
    print(Cipher_message)
    print("Cipher message : ", ''.join(str('%0.2X' % n).decode("hex") for n in Cipher_message))
    decrypted_message = Decryption(Cipher_message, CipherKeyArray, CipherKeySize)
    print(decrypted_message)
    print("Decrypted message : ", ''.join(str('%0.2X' % n).decode("hex") for n in decrypted_message))

main()
