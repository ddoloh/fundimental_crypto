'''
AES
input : 128 bits
output : 128 bits
cipher key : 128 or 192 or 256 bits
##########################################
1. xor operation with roundKey(addroundkey)
2. substitute bytes(SubBytes)
3. Shift Rows
4. Mix Columns
5. xor operation with roundKey(addroundKey)
6. repeat round-1 times (2 -5)
7. operate the last round without MixColumns
###########################################
'''

###          Key Length    Block Length    Number of Rounds
### AES-128      4              4                 10
### AES-192      6              4                 12
### AES-256      8              4                 14

import finite_field_mult

SBOX = [
#ROW  0    1     2     3     4     5     6     7      8     9    10    11    12    13    14    15
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, # ROW 0

    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, # ROW 1

    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, # ROW 2

    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, # ROW 3

    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, # ROW 4

    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, # ROW 5

    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, # ROW 6

    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, # ROW 7

    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, # ROW 8

    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, # ROW 9

    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, # ROW 10

    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, # ROW 11

    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, # ROW 12

    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, # ROW 13

    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, # ROW 14

    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, # ROW 15
]

inv_SBOX = [
#ROW 0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, # ROW 0

    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, # ROW 1

    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, # ROW 2

    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, # ROW 3

    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, # ROW 4

    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, # ROW 5

    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, # ROW 6

    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, # ROW 7

    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, # ROW 8

    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, # ROW 9

    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, # ROW 10

    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, # ROW 11

    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, # ROW 12

    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, # ROW 13

    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, # ROW 14

    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, # ROW 15
]
'''
Rcon = (
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
)

'''
Rcon = [ # 236 elements?
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,

    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,

    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,

    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,

    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,

    0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,

    0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,

    0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,

    0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,

    0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,

    0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,

    0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,

    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,

    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,

    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,

    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,

    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,

    0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,

    0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,

    0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb ]

# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)
# size of state column
Nb = 4

def bytes2matrix(text):
    ##### 16-byte array to 4*4 matrix #####
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]


def matrix2bytes(matrix):
    ##### 4*4 matrix to 16-byte array #####
    return bytes(sum(matrix, []))

''' inverse transformation of SubBytes function is invSubBytes function  '''

def SubBytes(s_rc):
    for i in range(4):
        for j in range(4):
            s_rc[i][j] = SBOX[s_rc[i][j]]

def invSubBytes(s_rc):
    for i in range(4):
        for j in range(4):
            s_rc[i][j] = inv_SBOX[s_rc[i][j]]


def ShiftRows(state):
    state[0][1], state[1][1], state[2][1], state[3][1] = state[1][1], state[2][1], state[3][1], state[0][1]
    state[0][2], state[1][2], state[2][2], state[3][2] = state[2][2], state[3][2], state[0][2], state[1][2]
    state[0][3], state[1][3], state[2][3], state[3][3] = state[3][3], state[0][3], state[1][3], state[2][3]

def inv_ShiftRows(state):
    state[0][1], state[1][1], state[2][1], state[3][1] = state[3][1], state[0][1], state[1][1], state[2][1]
    state[0][2], state[1][2], state[2][2], state[3][2] = state[2][2], state[3][2], state[0][2], state[1][2]
    state[0][3], state[1][3], state[2][3], state[3][3] = state[1][3], state[2][3], state[3][3], state[0][3]

def CopyColumn(input_col, output_col):
    output_col.extend(input_col)

def mixColumn(input_col):
    output_col = []
    for c in range(4):
        output_col.extend(SubmixColumn(input_col[c]))

    return output_col

def SubmixColumn(col):
    t = col[0] ^ col[1] ^ col[2] ^ col[3]
    u = col[0]
    col[0] ^= t ^ xtime(col[0] ^ col[1])
    col[1] ^= t ^ xtime(col[1] ^ col[2])
    col[2] ^= t ^ xtime(col[2] ^ col[3])
    col[3] ^= t ^ xtime(col[3] ^ u)
    return col

'''    
def SubmixColumn(col):
    T = []
    CopyColumn(col, T)
    col[0] = (finite_field_mult(0x02, T[0])) ^ (finite_field_mult(0x03, T[1])) ^ T[2] ^ T[3]
    col[1] = T[0] ^ (finite_field_mult(0x02, T[1])) ^ finite_field_mult(0x03, T[2]) % T[3]
    col[2] = T[0] ^ T[1] ^ finite_field_mult(0x02, T[2]) ^ finite_field_mult(0x03, T[3])
    col[3] = finite_field_mult(0x03, T[0]) ^ T[1] ^ T[2] ^ finite_field_mult(0x02, T[3])
'''

def AddroundKey(State, Key_Word):
    for i in range(4):
        for j in range(4):
            State[i][j] ^= Key_Word[i][j]

def shiftLeft(block):
    for i in range(len(block)):
        T = block[0]
        block[:] = block[1:]
        block.append(T)

def SubWord(state):
    ### substitute first four bytes of input state ###
    return SBOX[state]

def RotWord(state):
    T = state[0]
    state[0] = state[1]
    state[1] = state[2]
    state[2] = state[3]
    state[3] = T
    return state

def KeyExpansion(Key, Key_size, RoundKey, RoundKeySize):

    i = 0
    rconIteration = 1
    word = [0, 0, 0, 0]

    RoundKey = []
    while len(RoundKey) < RoundKeySize: RoundKey.append(0)

    for j in range(Key_size): RoundKey[j] = Key[j]

    i += Key_size
    while i < RoundKeySize:
        for k in range(4): word[k] = RoundKey[(i - 4) + k]

        # Every 16,24,32 bytes
        if i % Key_size == 0:
            word = RotWord(word)
            for r in range(4):
                word[r] = SubWord(word[r])
            word[0] ^= Rcon[rconIteration]
            rconIteration += 1

        # For 256-bit keys, we add an extra Sbox to the calculation
        if Key_size == 256/8 and (i % Key_size) == Nb*4:
            for e in range(4): word[e] = SubWord(word[e])

        for m in range(4):
            RoundKey[i] = RoundKey[i - Key_size] ^ word[m]
            i += 1

    return RoundKey

def Encryption(plaintext,key, numberOfRounds):
    state = bytes2matrix(plaintext)
    key = bytes2matrix(key)
    RoundKey = []
    RoundKeySize = (numberOfRounds+1) * Nb
    print(key)
    KeyExpansion(key, len(key), RoundKey, RoundKeySize)
    print(RoundKey)
    #S = AddroundKey(T, key)


    for i in range(numberOfRounds):
        SubBytes(state)
        ShiftRows(state)
        mixColumn(state)
        AddroundKey(state, key)

    SubBytes(state)
    ShiftRows(state)
    AddroundKey(state, key)

    output_state = bytes2matrix(state)

    return output_state

def H2B(letter):
    if (letter.isdigit()):
        return int(letter)
    elif (letter == "a" or letter == "A"):
        return 10
    elif (letter == "b" or letter == "B"):
        return 11
    elif (letter == "c" or letter == "C"):
        return 12
    elif (letter == "d" or letter == "D"):
        return 13
    elif (letter == "e" or letter == "E"):
        return 14
    elif (letter == "f" or letter == "F"):
        return 15

def HexStringToBinaryArray(inString):
    result = []
    value = 0
    for currentLetter in inString:
        value = H2B(currentLetter)
        if (value == None):
            return None
        result.append(value / 8)
        value = value % 8
        result.append(value / 4)
        value = value % 4
        result.append(value / 2)
        value = value % 2
        result.append(value)
    return result

def main():
    plaintext = HexStringToBinaryArray("0123456789ABCDEF")
    key = HexStringToBinaryArray("FEDCBA9876543210")
    output = Encryption(plaintext, key, 10)
    print(output)


main()
